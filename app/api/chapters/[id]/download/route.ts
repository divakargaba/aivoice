import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { chapters, projects } from "@/db/schema";
import { eq, and, asc } from "drizzle-orm";
import JSZip from "jszip";

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { userId } = await auth();
        if (!userId) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        const { id } = await params;

        // Get chapter with all text blocks and audio segments
        const chapter = await db.query.chapters.findFirst({
            where: eq(chapters.id, id),
            with: {
                project: true,
                textBlocks: {
                    orderBy: (textBlocks, { asc }) => [asc(textBlocks.idx)],
                    with: {
                        audioSegment: true,
                        speakerCharacter: true,
                    },
                },
            },
        });

        if (!chapter) {
            return NextResponse.json(
                { error: "Chapter not found" },
                { status: 404 }
            );
        }

        // Verify ownership
        if (chapter.project.userId !== userId) {
            return NextResponse.json({ error: "Access denied" }, { status: 403 });
        }

        // Filter blocks with audio
        const blocksWithAudio = chapter.textBlocks.filter(
            (block) => block.audioSegment
        );

        if (blocksWithAudio.length === 0) {
            return NextResponse.json(
                { error: "No audio segments found" },
                { status: 404 }
            );
        }

        // Create ZIP file
        const zip = new JSZip();

        // Create a README with chapter info
        const readme = `# ${chapter.title}

## Audio Segments

This ZIP contains ${blocksWithAudio.length} audio segments from the chapter.

Files are named in order:
- Format: {idx:03d}_{speaker}_{emotion}.mp3
- idx: Block index (000, 001, 002...)
- speaker: Character name or Narrator
- emotion: Emotion tag (if present)

## Playback Order

${blocksWithAudio
            .map((block) => {
                const speaker = block.speakerCharacter?.name || "Narrator";
                const emotion =
                    (block.meta as any)?.emotion &&
                        (block.meta as any).emotion !== "neutral"
                        ? `[${(block.meta as any).emotion}]`
                        : "";
                return `${String(block.idx).padStart(3, "0")}. ${speaker} ${emotion}: ${block.text.substring(0, 60)}${block.text.length > 60 ? "..." : ""}`;
            })
            .join("\n")}

---
Generated by AI Voice Project
`;

        zip.file("README.md", readme);

        // Create a simple playlist file (M3U format)
        const playlistContent = blocksWithAudio
            .map((block) => {
                const speaker = block.speakerCharacter?.name || "Narrator";
                const emotion =
                    (block.meta as any)?.emotion &&
                        (block.meta as any).emotion !== "neutral"
                        ? `_${(block.meta as any).emotion}`
                        : "";
                const filename = `${String(block.idx).padStart(3, "0")}_${speaker.replace(/[^a-z0-9]/gi, "-")}${emotion}.mp3`;
                return `#EXTINF:-1,${speaker} - Block ${block.idx}\n${filename}`;
            })
            .join("\n");

        zip.file("playlist.m3u", playlistContent);

        // Download each audio file and add to ZIP
        for (const block of blocksWithAudio) {
            if (!block.audioSegment) continue;

            const speaker = block.speakerCharacter?.name || "Narrator";
            const emotion =
                (block.meta as any)?.emotion &&
                    (block.meta as any).emotion !== "neutral"
                    ? `_${(block.meta as any).emotion}`
                    : "";
            const filename = `${String(block.idx).padStart(3, "0")}_${speaker.replace(/[^a-z0-9]/gi, "-")}${emotion}.mp3`;

            try {
                // Fetch the audio file from Supabase
                const audioResponse = await fetch(block.audioSegment.audioUrl);
                if (audioResponse.ok) {
                    const audioBuffer = await audioResponse.arrayBuffer();
                    zip.file(filename, audioBuffer);
                }
            } catch (error) {
                console.error(`Failed to download audio for block ${block.idx}:`, error);
                // Continue with other files
            }
        }

        // Generate ZIP
        const zipBuffer = await zip.generateAsync({
            type: "nodebuffer",
            compression: "DEFLATE",
            compressionOptions: { level: 6 },
        });

        // Return ZIP file
        const chapterSlug = chapter.title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-|-$/g, "");

        return new NextResponse(zipBuffer, {
            headers: {
                "Content-Type": "application/zip",
                "Content-Disposition": `attachment; filename="chapter-${chapterSlug}.zip"`,
            },
        });
    } catch (error) {
        console.error("Chapter download failed:", error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : "Download failed" },
            { status: 500 }
        );
    }
}

